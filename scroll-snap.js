!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I():"function"==typeof define&&define.amd?define([],I):"object"==typeof exports?exports["scroll-snap"]=I():g["scroll-snap"]=I()}(window,function(){return function(g){var I={};function n(C){if(I[C])return I[C].exports;var t=I[C]={i:C,l:!1,exports:{}};return g[C].call(t.exports,t,t.exports,n),t.l=!0,t.exports}return n.m=g,n.c=I,n.d=function(g,I,C){n.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:C})},n.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},n.t=function(g,I){if(1&I&&(g=n(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var C=Object.create(null);if(n.r(C),Object.defineProperty(C,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var t in g)n.d(C,t,function(I){return g[I]}.bind(null,t));return C},n.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(I,"a",I),I},n.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},n.p="",n(n.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/index.ts\nvar SCROLL_TIMEOUT_DEFAULT = 300;\nvar SCROLL_TIME_DEFAULT = 2;\nvar NOOP = function () { };\nfunction easeInCubic(t, b, c, d) {\n    return c * (t = t / d) * t * t + b;\n}\nfunction position(start, end, elapsed, duration) {\n    if (elapsed > duration) {\n        return end;\n    }\n    return easeInCubic(elapsed, start, end - start, duration);\n}\nvar ScrollSnap = /** @class */ (function () {\n    function ScrollSnap(element, config) {\n        var _this = this;\n        this.animating = false;\n        this.lastScrollValue = {\n            x: 0,\n            y: 0,\n        };\n        this.startAnimation = function () {\n            _this.speedDeltaX = _this.checkScrollSpeed(_this.target.scrollLeft, 'x');\n            _this.speedDeltaY = _this.checkScrollSpeed(_this.target.scrollTop, 'y');\n            if (_this.animating || (_this.speedDeltaX === 0 && _this.speedDeltaY === 0)) {\n                return;\n            }\n            _this.handler(_this.target);\n        };\n        this.animationHandler = function () {\n            // if we don't move a thing, we can ignore the timeout: if we did, there'd be another timeout added for this.scrollStart+1.\n            if (_this.scrollStart.y === _this.target.scrollTop &&\n                _this.scrollStart.x === _this.target.scrollLeft) {\n                // ignore timeout\n                return;\n            }\n            // detect direction of scroll. negative is up, positive is down.\n            var direction = {\n                y: _this.speedDeltaY > 0 ? 1 : -1,\n                x: _this.speedDeltaX > 0 ? 1 : -1,\n            };\n            // get the next snap-point to snap-to\n            var snapPoint = _this.getNextSnapPoint(_this.target, direction);\n            _this.target.removeEventListener('scroll', _this.startAnimation, false);\n            _this.animating = true;\n            // smoothly move to the snap point\n            _this.smoothScroll(_this.target, snapPoint, function () {\n                // after moving to the snap point, rebind the scroll event handler\n                _this.animating = false;\n                _this.target.addEventListener('scroll', _this.startAnimation, false);\n                _this.onAnimationEnd();\n            });\n            // we just jumped to the snapPoint, so this will be our next this.scrollStart\n            if (!isNaN(snapPoint.x) || !isNaN(snapPoint.y)) {\n                _this.scrollStart = snapPoint;\n            }\n        };\n        this.element = element;\n        this.config = config;\n        if (config.scrollTimeout &&\n            (isNaN(config.scrollTimeout) || typeof config.scrollTimeout === 'boolean')) {\n            throw new Error(\"Optional config property 'scrollTimeout' is not valid, expected NUMBER but found \" + (typeof config.scrollTimeout).toUpperCase());\n        }\n        this.SCROLL_TIMEOUT = config.scrollTimeout || SCROLL_TIMEOUT_DEFAULT;\n        if (config.scrollTime && (isNaN(config.scrollTime) || typeof config.scrollTime === 'boolean')) {\n            throw new Error(\"Optional config property 'scrollTime' is not valid, expected NUMBER but found \" + (typeof config.scrollTime).toUpperCase());\n        }\n        this.SCROLL_TIME = config.scrollTime || SCROLL_TIME_DEFAULT;\n        if (!config.scrollSnapDestination) {\n            throw new Error('Required config property scrollSnapDestination is not defined');\n        }\n        this.SCROLL_SNAP_DESTINATION = config.scrollSnapDestination;\n    }\n    ScrollSnap.prototype.checkScrollSpeed = function (value, axis) {\n        var _this = this;\n        var clear = function () {\n            _this.lastScrollValue[axis] = null;\n        };\n        var newValue = value;\n        var delta;\n        if (this.lastScrollValue[axis] !== null) {\n            delta = newValue - this.lastScrollValue[axis];\n        }\n        else {\n            delta = 0;\n        }\n        this.lastScrollValue[axis] = newValue;\n        this.scrollSpeedTimer && clearTimeout(this.scrollSpeedTimer);\n        this.scrollSpeedTimer = setTimeout(clear, 50);\n        return delta;\n    };\n    ScrollSnap.prototype.saveDeclaration = function (obj) {\n        this.snapLengthUnit = this.parseSnapCoordValue(this.SCROLL_SNAP_DESTINATION);\n    };\n    ScrollSnap.prototype.bindElement = function (element) {\n        this.target = element;\n        /**\n         * set webkit-overflow-scrolling to auto.\n         * this prevents momentum scrolling on ios devices\n         * causing flickering behaviours and delayed transitions.\n         */\n        this.target.style.overflow = 'auto';\n        // @ts-ignore\n        this.target.style.webkitOverflowScrolling = 'auto';\n        this.target.addEventListener('scroll', this.startAnimation, false);\n        this.saveDeclaration(this.target);\n    };\n    ScrollSnap.prototype.unbindElement = function (element) {\n        // @ts-ignore\n        element.style.webkitOverflowScrolling = null;\n        element.removeEventListener('scroll', this.startAnimation, false);\n    };\n    /**\n     * scroll handler\n     * this is the callback for scroll events.\n     */\n    ScrollSnap.prototype.handler = function (target) {\n        // if currently this.animating, stop it. this prevents flickering.\n        if (this.animationFrame) {\n            clearTimeout(this.animationFrame);\n        }\n        // if a previous timeout exists, clear it.\n        if (this.scrollHandlerTimer) {\n            // we only want to call a timeout once after scrolling..\n            clearTimeout(this.scrollHandlerTimer);\n        }\n        else {\n            this.scrollStart = {\n                y: target.scrollTop,\n                x: target.scrollLeft,\n            };\n        }\n        this.scrollHandlerTimer = setTimeout(this.animationHandler, this.SCROLL_TIMEOUT);\n    };\n    ScrollSnap.prototype.getNextSnapPoint = function (target, direction) {\n        // get snap length\n        var snapLength = {\n            y: this.roundByDirection(direction.y, this.getYSnapLength(this.target, this.snapLengthUnit.y)),\n            x: this.roundByDirection(direction.x, this.getXSnapLength(this.target, this.snapLengthUnit.x)),\n        };\n        var top = this.target.scrollTop;\n        var left = this.target.scrollLeft;\n        // calc current and initial snappoint\n        var currentPoint = {\n            y: top / snapLength.y || 1,\n            x: left / snapLength.x || 1,\n        };\n        var nextPoint = {\n            y: 0,\n            x: 0,\n        };\n        // set target and bounds by direction\n        nextPoint.y = this.roundByDirection(direction.y, currentPoint.y);\n        nextPoint.x = this.roundByDirection(direction.x, currentPoint.x);\n        // calculate where to scroll\n        var scrollTo = {\n            y: nextPoint.y * snapLength.y,\n            x: nextPoint.x * snapLength.x,\n        };\n        // stay in bounds (minimum: 0, maxmimum: absolute height)\n        scrollTo.y = this.stayInBounds(0, target.scrollHeight, scrollTo.y);\n        scrollTo.x = this.stayInBounds(0, target.scrollWidth, scrollTo.x);\n        return scrollTo;\n    };\n    ScrollSnap.prototype.roundByDirection = function (direction, currentPoint) {\n        if (direction === -1) {\n            // when we go up, we floor the number to jump to the next snap-point in scroll direction\n            return Math.floor(currentPoint);\n        }\n        // go down, we ceil the number to jump to the next in view.\n        return Math.ceil(currentPoint);\n    };\n    ScrollSnap.prototype.stayInBounds = function (min, max, destined) {\n        return Math.max(Math.min(destined, max), min);\n    };\n    ScrollSnap.prototype.parseSnapCoordValue = function (declaration) {\n        // regex to parse lengths\n        var regex = /(\\d+)(px|%|vw) (\\d+)(px|%|vh)/g;\n        // defaults\n        var parsed = {\n            y: {\n                value: 0,\n                unit: 'px',\n            },\n            x: {\n                value: 0,\n                unit: 'px',\n            },\n        };\n        var parsable;\n        var result;\n        // parse value and unit\n        if (parsable !== null) {\n            result = regex.exec(declaration);\n            // if regexp fails, value is null\n            if (result !== null) {\n                parsed.x = {\n                    value: Number(result[1]),\n                    unit: result[2],\n                };\n                parsed.y = {\n                    value: Number(result[3]),\n                    unit: result[4],\n                };\n            }\n        }\n        return parsed;\n    };\n    ScrollSnap.prototype.getYSnapLength = function (obj, declaration) {\n        if (declaration.unit === 'vh') {\n            // when using vh, one snap is the length of vh / 100 * value\n            return ((Math.max(document.documentElement.clientHeight, window.innerHeight || 1) / 100) *\n                declaration.value);\n        }\n        else if (declaration.unit === '%') {\n            // when using %, one snap is the length of element height / 100 * value\n            return (obj.offsetHeight / 100) * declaration.value;\n        }\n        else {\n            // when using px, one snap is the length of element height / value\n            return obj.offsetHeight / declaration.value;\n        }\n    };\n    ScrollSnap.prototype.getXSnapLength = function (obj, declaration) {\n        if (declaration.unit === 'vw') {\n            // when using vw, one snap is the length of vw / 100 * value\n            return ((Math.max(document.documentElement.clientWidth, window.innerWidth || 1) / 100) *\n                declaration.value);\n        }\n        else if (declaration.unit === '%') {\n            // when using %, one snap is the length of element width / 100 * value\n            return (obj.offsetWidth / 100) * declaration.value;\n        }\n        else {\n            // when using px, one snap is the length of element width / value\n            return obj.offsetWidth / declaration.value;\n        }\n    };\n    ScrollSnap.prototype.isEdge = function (start) {\n        return (start.x === 0 && this.speedDeltaY === 0) || (start.y === 0 && this.speedDeltaX === 0);\n    };\n    ScrollSnap.prototype.smoothScroll = function (obj, end, callback) {\n        var start = {\n            y: obj.scrollTop,\n            x: obj.scrollLeft,\n        };\n        // get animation frame or a fallback\n        var requestAnimationFrame = window.requestAnimationFrame ||\n            window.webkitRequestAnimationFrame ||\n            function (fn) {\n                return window.setTimeout(fn, 15);\n            };\n        var duration = this.isEdge(start) ? 0 : this.SCROLL_TIME;\n        var startTime;\n        // setup the stepping function\n        function step(timestamp) {\n            if (!startTime) {\n                startTime = timestamp;\n            }\n            var elapsed = timestamp - startTime;\n            // change position on y-axis if result is a number.\n            if (!isNaN(end.y)) {\n                obj.scrollTop = position(start.y, end.y, elapsed, duration);\n            }\n            // change position on x-axis if result is a number.\n            if (!isNaN(end.x)) {\n                obj.scrollLeft = position(start.x, end.x, elapsed, duration);\n            }\n            // check if we are over due;\n            if (elapsed < duration) {\n                requestAnimationFrame(step);\n            }\n            else {\n                // is there a callback?\n                if (typeof callback === 'function') {\n                    // stop execution and run the callback\n                    return callback(end);\n                }\n            }\n        }\n        this.animationFrame = requestAnimationFrame(step);\n    };\n    ScrollSnap.prototype.bind = function (callback) {\n        this.onAnimationEnd = typeof callback === 'function' ? callback : NOOP;\n        this.bindElement(this.element);\n    };\n    ScrollSnap.prototype.unbind = function () {\n        this.unbindElement(this.element);\n    };\n    return ScrollSnap;\n}());\n/* harmony default export */ var src = (ScrollSnap);\n\n// CONCATENATED MODULE: ./demo/src/index.ts\n\nvar snapConfig = {\n    scrollSnapDestination: '0% 90%',\n    scrollTimeout: 100,\n    scrollTime: 300,\n};\nfunction callback() {\n    console.log('snap');\n}\nvar src_element = document.getElementById('container');\nvar snapObject = new src(src_element, snapConfig);\nsnapObject.bind(callback);\n// unbind element\n// snapObject.unbind();\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zY3JvbGwtc25hcC8uL3NyYy9pbmRleC50cz83MWJkIiwid2VicGFjazovL3Njcm9sbC1zbmFwLy4vZGVtby9zcmMvaW5kZXgudHM/ZTc3NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNjLGtEQUFVLEVBQUM7OztBQ2xTZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxXQUFPO0FBQ1gscUJBQXFCLEdBQVUsQ0FBQyxXQUFPO0FBQ3ZDO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFNDUk9MTF9USU1FT1VUX0RFRkFVTFQgPSAzMDA7XG52YXIgU0NST0xMX1RJTUVfREVGQVVMVCA9IDI7XG52YXIgTk9PUCA9IGZ1bmN0aW9uICgpIHsgfTtcbmZ1bmN0aW9uIGVhc2VJbkN1YmljKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqICh0ID0gdCAvIGQpICogdCAqIHQgKyBiO1xufVxuZnVuY3Rpb24gcG9zaXRpb24oc3RhcnQsIGVuZCwgZWxhcHNlZCwgZHVyYXRpb24pIHtcbiAgICBpZiAoZWxhcHNlZCA+IGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBlYXNlSW5DdWJpYyhlbGFwc2VkLCBzdGFydCwgZW5kIC0gc3RhcnQsIGR1cmF0aW9uKTtcbn1cbnZhciBTY3JvbGxTbmFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbFNuYXAoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFZhbHVlID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zcGVlZERlbHRhWCA9IF90aGlzLmNoZWNrU2Nyb2xsU3BlZWQoX3RoaXMudGFyZ2V0LnNjcm9sbExlZnQsICd4Jyk7XG4gICAgICAgICAgICBfdGhpcy5zcGVlZERlbHRhWSA9IF90aGlzLmNoZWNrU2Nyb2xsU3BlZWQoX3RoaXMudGFyZ2V0LnNjcm9sbFRvcCwgJ3knKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hbmltYXRpbmcgfHwgKF90aGlzLnNwZWVkRGVsdGFYID09PSAwICYmIF90aGlzLnNwZWVkRGVsdGFZID09PSAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmhhbmRsZXIoX3RoaXMudGFyZ2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25IYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgbW92ZSBhIHRoaW5nLCB3ZSBjYW4gaWdub3JlIHRoZSB0aW1lb3V0OiBpZiB3ZSBkaWQsIHRoZXJlJ2QgYmUgYW5vdGhlciB0aW1lb3V0IGFkZGVkIGZvciB0aGlzLnNjcm9sbFN0YXJ0KzEuXG4gICAgICAgICAgICBpZiAoX3RoaXMuc2Nyb2xsU3RhcnQueSA9PT0gX3RoaXMudGFyZ2V0LnNjcm9sbFRvcCAmJlxuICAgICAgICAgICAgICAgIF90aGlzLnNjcm9sbFN0YXJ0LnggPT09IF90aGlzLnRhcmdldC5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHRpbWVvdXRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZXRlY3QgZGlyZWN0aW9uIG9mIHNjcm9sbC4gbmVnYXRpdmUgaXMgdXAsIHBvc2l0aXZlIGlzIGRvd24uXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IF90aGlzLnNwZWVkRGVsdGFZID4gMCA/IDEgOiAtMSxcbiAgICAgICAgICAgICAgICB4OiBfdGhpcy5zcGVlZERlbHRhWCA+IDAgPyAxIDogLTEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBuZXh0IHNuYXAtcG9pbnQgdG8gc25hcC10b1xuICAgICAgICAgICAgdmFyIHNuYXBQb2ludCA9IF90aGlzLmdldE5leHRTbmFwUG9pbnQoX3RoaXMudGFyZ2V0LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgX3RoaXMudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF90aGlzLnN0YXJ0QW5pbWF0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgICBfdGhpcy5hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgLy8gc21vb3RobHkgbW92ZSB0byB0aGUgc25hcCBwb2ludFxuICAgICAgICAgICAgX3RoaXMuc21vb3RoU2Nyb2xsKF90aGlzLnRhcmdldCwgc25hcFBvaW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgbW92aW5nIHRvIHRoZSBzbmFwIHBvaW50LCByZWJpbmQgdGhlIHNjcm9sbCBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3RoaXMudGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF90aGlzLnN0YXJ0QW5pbWF0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMub25BbmltYXRpb25FbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2UganVzdCBqdW1wZWQgdG8gdGhlIHNuYXBQb2ludCwgc28gdGhpcyB3aWxsIGJlIG91ciBuZXh0IHRoaXMuc2Nyb2xsU3RhcnRcbiAgICAgICAgICAgIGlmICghaXNOYU4oc25hcFBvaW50LngpIHx8ICFpc05hTihzbmFwUG9pbnQueSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zY3JvbGxTdGFydCA9IHNuYXBQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIGlmIChjb25maWcuc2Nyb2xsVGltZW91dCAmJlxuICAgICAgICAgICAgKGlzTmFOKGNvbmZpZy5zY3JvbGxUaW1lb3V0KSB8fCB0eXBlb2YgY29uZmlnLnNjcm9sbFRpbWVvdXQgPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbmFsIGNvbmZpZyBwcm9wZXJ0eSAnc2Nyb2xsVGltZW91dCcgaXMgbm90IHZhbGlkLCBleHBlY3RlZCBOVU1CRVIgYnV0IGZvdW5kIFwiICsgKHR5cGVvZiBjb25maWcuc2Nyb2xsVGltZW91dCkudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5TQ1JPTExfVElNRU9VVCA9IGNvbmZpZy5zY3JvbGxUaW1lb3V0IHx8IFNDUk9MTF9USU1FT1VUX0RFRkFVTFQ7XG4gICAgICAgIGlmIChjb25maWcuc2Nyb2xsVGltZSAmJiAoaXNOYU4oY29uZmlnLnNjcm9sbFRpbWUpIHx8IHR5cGVvZiBjb25maWcuc2Nyb2xsVGltZSA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uYWwgY29uZmlnIHByb3BlcnR5ICdzY3JvbGxUaW1lJyBpcyBub3QgdmFsaWQsIGV4cGVjdGVkIE5VTUJFUiBidXQgZm91bmQgXCIgKyAodHlwZW9mIGNvbmZpZy5zY3JvbGxUaW1lKS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLlNDUk9MTF9USU1FID0gY29uZmlnLnNjcm9sbFRpbWUgfHwgU0NST0xMX1RJTUVfREVGQVVMVDtcbiAgICAgICAgaWYgKCFjb25maWcuc2Nyb2xsU25hcERlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIGNvbmZpZyBwcm9wZXJ0eSBzY3JvbGxTbmFwRGVzdGluYXRpb24gaXMgbm90IGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLlNDUk9MTF9TTkFQX0RFU1RJTkFUSU9OID0gY29uZmlnLnNjcm9sbFNuYXBEZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuY2hlY2tTY3JvbGxTcGVlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5sYXN0U2Nyb2xsVmFsdWVbYXhpc10gPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGRlbHRhO1xuICAgICAgICBpZiAodGhpcy5sYXN0U2Nyb2xsVmFsdWVbYXhpc10gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbHRhID0gbmV3VmFsdWUgLSB0aGlzLmxhc3RTY3JvbGxWYWx1ZVtheGlzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RTY3JvbGxWYWx1ZVtheGlzXSA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLnNjcm9sbFNwZWVkVGltZXIgJiYgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsU3BlZWRUaW1lcik7XG4gICAgICAgIHRoaXMuc2Nyb2xsU3BlZWRUaW1lciA9IHNldFRpbWVvdXQoY2xlYXIsIDUwKTtcbiAgICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH07XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuc2F2ZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB0aGlzLnNuYXBMZW5ndGhVbml0ID0gdGhpcy5wYXJzZVNuYXBDb29yZFZhbHVlKHRoaXMuU0NST0xMX1NOQVBfREVTVElOQVRJT04pO1xuICAgIH07XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuYmluZEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZyB0byBhdXRvLlxuICAgICAgICAgKiB0aGlzIHByZXZlbnRzIG1vbWVudHVtIHNjcm9sbGluZyBvbiBpb3MgZGV2aWNlc1xuICAgICAgICAgKiBjYXVzaW5nIGZsaWNrZXJpbmcgYmVoYXZpb3VycyBhbmQgZGVsYXllZCB0cmFuc2l0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMudGFyZ2V0LnN0eWxlLndlYmtpdE92ZXJmbG93U2Nyb2xsaW5nID0gJ2F1dG8nO1xuICAgICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnN0YXJ0QW5pbWF0aW9uLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2F2ZURlY2xhcmF0aW9uKHRoaXMudGFyZ2V0KTtcbiAgICB9O1xuICAgIFNjcm9sbFNuYXAucHJvdG90eXBlLnVuYmluZEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVsZW1lbnQuc3R5bGUud2Via2l0T3ZlcmZsb3dTY3JvbGxpbmcgPSBudWxsO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuc3RhcnRBbmltYXRpb24sIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHNjcm9sbCBoYW5kbGVyXG4gICAgICogdGhpcyBpcyB0aGUgY2FsbGJhY2sgZm9yIHNjcm9sbCBldmVudHMuXG4gICAgICovXG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuaGFuZGxlciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgLy8gaWYgY3VycmVudGx5IHRoaXMuYW5pbWF0aW5nLCBzdG9wIGl0LiB0aGlzIHByZXZlbnRzIGZsaWNrZXJpbmcuXG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltYXRpb25GcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYSBwcmV2aW91cyB0aW1lb3V0IGV4aXN0cywgY2xlYXIgaXQuXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEhhbmRsZXJUaW1lcikge1xuICAgICAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIGNhbGwgYSB0aW1lb3V0IG9uY2UgYWZ0ZXIgc2Nyb2xsaW5nLi5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNjcm9sbEhhbmRsZXJUaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgIHk6IHRhcmdldC5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgeDogdGFyZ2V0LnNjcm9sbExlZnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsSGFuZGxlclRpbWVyID0gc2V0VGltZW91dCh0aGlzLmFuaW1hdGlvbkhhbmRsZXIsIHRoaXMuU0NST0xMX1RJTUVPVVQpO1xuICAgIH07XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuZ2V0TmV4dFNuYXBQb2ludCA9IGZ1bmN0aW9uICh0YXJnZXQsIGRpcmVjdGlvbikge1xuICAgICAgICAvLyBnZXQgc25hcCBsZW5ndGhcbiAgICAgICAgdmFyIHNuYXBMZW5ndGggPSB7XG4gICAgICAgICAgICB5OiB0aGlzLnJvdW5kQnlEaXJlY3Rpb24oZGlyZWN0aW9uLnksIHRoaXMuZ2V0WVNuYXBMZW5ndGgodGhpcy50YXJnZXQsIHRoaXMuc25hcExlbmd0aFVuaXQueSkpLFxuICAgICAgICAgICAgeDogdGhpcy5yb3VuZEJ5RGlyZWN0aW9uKGRpcmVjdGlvbi54LCB0aGlzLmdldFhTbmFwTGVuZ3RoKHRoaXMudGFyZ2V0LCB0aGlzLnNuYXBMZW5ndGhVbml0LngpKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMudGFyZ2V0LnNjcm9sbFRvcDtcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnRhcmdldC5zY3JvbGxMZWZ0O1xuICAgICAgICAvLyBjYWxjIGN1cnJlbnQgYW5kIGluaXRpYWwgc25hcHBvaW50XG4gICAgICAgIHZhciBjdXJyZW50UG9pbnQgPSB7XG4gICAgICAgICAgICB5OiB0b3AgLyBzbmFwTGVuZ3RoLnkgfHwgMSxcbiAgICAgICAgICAgIHg6IGxlZnQgLyBzbmFwTGVuZ3RoLnggfHwgMSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5leHRQb2ludCA9IHtcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICB9O1xuICAgICAgICAvLyBzZXQgdGFyZ2V0IGFuZCBib3VuZHMgYnkgZGlyZWN0aW9uXG4gICAgICAgIG5leHRQb2ludC55ID0gdGhpcy5yb3VuZEJ5RGlyZWN0aW9uKGRpcmVjdGlvbi55LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICAgIG5leHRQb2ludC54ID0gdGhpcy5yb3VuZEJ5RGlyZWN0aW9uKGRpcmVjdGlvbi54LCBjdXJyZW50UG9pbnQueCk7XG4gICAgICAgIC8vIGNhbGN1bGF0ZSB3aGVyZSB0byBzY3JvbGxcbiAgICAgICAgdmFyIHNjcm9sbFRvID0ge1xuICAgICAgICAgICAgeTogbmV4dFBvaW50LnkgKiBzbmFwTGVuZ3RoLnksXG4gICAgICAgICAgICB4OiBuZXh0UG9pbnQueCAqIHNuYXBMZW5ndGgueCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc3RheSBpbiBib3VuZHMgKG1pbmltdW06IDAsIG1heG1pbXVtOiBhYnNvbHV0ZSBoZWlnaHQpXG4gICAgICAgIHNjcm9sbFRvLnkgPSB0aGlzLnN0YXlJbkJvdW5kcygwLCB0YXJnZXQuc2Nyb2xsSGVpZ2h0LCBzY3JvbGxUby55KTtcbiAgICAgICAgc2Nyb2xsVG8ueCA9IHRoaXMuc3RheUluQm91bmRzKDAsIHRhcmdldC5zY3JvbGxXaWR0aCwgc2Nyb2xsVG8ueCk7XG4gICAgICAgIHJldHVybiBzY3JvbGxUbztcbiAgICB9O1xuICAgIFNjcm9sbFNuYXAucHJvdG90eXBlLnJvdW5kQnlEaXJlY3Rpb24gPSBmdW5jdGlvbiAoZGlyZWN0aW9uLCBjdXJyZW50UG9pbnQpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gd2UgZ28gdXAsIHdlIGZsb29yIHRoZSBudW1iZXIgdG8ganVtcCB0byB0aGUgbmV4dCBzbmFwLXBvaW50IGluIHNjcm9sbCBkaXJlY3Rpb25cbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGN1cnJlbnRQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ28gZG93biwgd2UgY2VpbCB0aGUgbnVtYmVyIHRvIGp1bXAgdG8gdGhlIG5leHQgaW4gdmlldy5cbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChjdXJyZW50UG9pbnQpO1xuICAgIH07XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuc3RheUluQm91bmRzID0gZnVuY3Rpb24gKG1pbiwgbWF4LCBkZXN0aW5lZCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oZGVzdGluZWQsIG1heCksIG1pbik7XG4gICAgfTtcbiAgICBTY3JvbGxTbmFwLnByb3RvdHlwZS5wYXJzZVNuYXBDb29yZFZhbHVlID0gZnVuY3Rpb24gKGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIC8vIHJlZ2V4IHRvIHBhcnNlIGxlbmd0aHNcbiAgICAgICAgdmFyIHJlZ2V4ID0gLyhcXGQrKShweHwlfHZ3KSAoXFxkKykocHh8JXx2aCkvZztcbiAgICAgICAgLy8gZGVmYXVsdHNcbiAgICAgICAgdmFyIHBhcnNlZCA9IHtcbiAgICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgICAgICB1bml0OiAncHgnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHg6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgICAgICB1bml0OiAncHgnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBhcnNhYmxlO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAvLyBwYXJzZSB2YWx1ZSBhbmQgdW5pdFxuICAgICAgICBpZiAocGFyc2FibGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlZ2V4LmV4ZWMoZGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgLy8gaWYgcmVnZXhwIGZhaWxzLCB2YWx1ZSBpcyBudWxsXG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnggPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIocmVzdWx0WzFdKSxcbiAgICAgICAgICAgICAgICAgICAgdW5pdDogcmVzdWx0WzJdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGFyc2VkLnkgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIocmVzdWx0WzNdKSxcbiAgICAgICAgICAgICAgICAgICAgdW5pdDogcmVzdWx0WzRdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9O1xuICAgIFNjcm9sbFNuYXAucHJvdG90eXBlLmdldFlTbmFwTGVuZ3RoID0gZnVuY3Rpb24gKG9iaiwgZGVjbGFyYXRpb24pIHtcbiAgICAgICAgaWYgKGRlY2xhcmF0aW9uLnVuaXQgPT09ICd2aCcpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdXNpbmcgdmgsIG9uZSBzbmFwIGlzIHRoZSBsZW5ndGggb2YgdmggLyAxMDAgKiB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuICgoTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDEpIC8gMTAwKSAqXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb24udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9uLnVuaXQgPT09ICclJykge1xuICAgICAgICAgICAgLy8gd2hlbiB1c2luZyAlLCBvbmUgc25hcCBpcyB0aGUgbGVuZ3RoIG9mIGVsZW1lbnQgaGVpZ2h0IC8gMTAwICogdmFsdWVcbiAgICAgICAgICAgIHJldHVybiAob2JqLm9mZnNldEhlaWdodCAvIDEwMCkgKiBkZWNsYXJhdGlvbi52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdXNpbmcgcHgsIG9uZSBzbmFwIGlzIHRoZSBsZW5ndGggb2YgZWxlbWVudCBoZWlnaHQgLyB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIG9iai5vZmZzZXRIZWlnaHQgLyBkZWNsYXJhdGlvbi52YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuZ2V0WFNuYXBMZW5ndGggPSBmdW5jdGlvbiAob2JqLCBkZWNsYXJhdGlvbikge1xuICAgICAgICBpZiAoZGVjbGFyYXRpb24udW5pdCA9PT0gJ3Z3Jykge1xuICAgICAgICAgICAgLy8gd2hlbiB1c2luZyB2dywgb25lIHNuYXAgaXMgdGhlIGxlbmd0aCBvZiB2dyAvIDEwMCAqIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gKChNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDEpIC8gMTAwKSAqXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb24udmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlY2xhcmF0aW9uLnVuaXQgPT09ICclJykge1xuICAgICAgICAgICAgLy8gd2hlbiB1c2luZyAlLCBvbmUgc25hcCBpcyB0aGUgbGVuZ3RoIG9mIGVsZW1lbnQgd2lkdGggLyAxMDAgKiB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIChvYmoub2Zmc2V0V2lkdGggLyAxMDApICogZGVjbGFyYXRpb24udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3aGVuIHVzaW5nIHB4LCBvbmUgc25hcCBpcyB0aGUgbGVuZ3RoIG9mIGVsZW1lbnQgd2lkdGggLyB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIG9iai5vZmZzZXRXaWR0aCAvIGRlY2xhcmF0aW9uLnZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY3JvbGxTbmFwLnByb3RvdHlwZS5pc0VkZ2UgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIChzdGFydC54ID09PSAwICYmIHRoaXMuc3BlZWREZWx0YVkgPT09IDApIHx8IChzdGFydC55ID09PSAwICYmIHRoaXMuc3BlZWREZWx0YVggPT09IDApO1xuICAgIH07XG4gICAgU2Nyb2xsU25hcC5wcm90b3R5cGUuc21vb3RoU2Nyb2xsID0gZnVuY3Rpb24gKG9iaiwgZW5kLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc3RhcnQgPSB7XG4gICAgICAgICAgICB5OiBvYmouc2Nyb2xsVG9wLFxuICAgICAgICAgICAgeDogb2JqLnNjcm9sbExlZnQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIGdldCBhbmltYXRpb24gZnJhbWUgb3IgYSBmYWxsYmFja1xuICAgICAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCAxNSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmlzRWRnZShzdGFydCkgPyAwIDogdGhpcy5TQ1JPTExfVElNRTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZTtcbiAgICAgICAgLy8gc2V0dXAgdGhlIHN0ZXBwaW5nIGZ1bmN0aW9uXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAodGltZXN0YW1wKSB7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbGFwc2VkID0gdGltZXN0YW1wIC0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgLy8gY2hhbmdlIHBvc2l0aW9uIG9uIHktYXhpcyBpZiByZXN1bHQgaXMgYSBudW1iZXIuXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGVuZC55KSkge1xuICAgICAgICAgICAgICAgIG9iai5zY3JvbGxUb3AgPSBwb3NpdGlvbihzdGFydC55LCBlbmQueSwgZWxhcHNlZCwgZHVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hhbmdlIHBvc2l0aW9uIG9uIHgtYXhpcyBpZiByZXN1bHQgaXMgYSBudW1iZXIuXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGVuZC54KSkge1xuICAgICAgICAgICAgICAgIG9iai5zY3JvbGxMZWZ0ID0gcG9zaXRpb24oc3RhcnQueCwgZW5kLngsIGVsYXBzZWQsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBvdmVyIGR1ZTtcbiAgICAgICAgICAgIGlmIChlbGFwc2VkIDwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSBhIGNhbGxiYWNrP1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBleGVjdXRpb24gYW5kIHJ1biB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgfTtcbiAgICBTY3JvbGxTbmFwLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub25BbmltYXRpb25FbmQgPSB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IE5PT1A7XG4gICAgICAgIHRoaXMuYmluZEVsZW1lbnQodGhpcy5lbGVtZW50KTtcbiAgICB9O1xuICAgIFNjcm9sbFNuYXAucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmJpbmRFbGVtZW50KHRoaXMuZWxlbWVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nyb2xsU25hcDtcbn0oKSk7XG5leHBvcnQgZGVmYXVsdCBTY3JvbGxTbmFwO1xuIiwiaW1wb3J0IFNjcm9sbFNuYXAgZnJvbSAnLi4vLi4vc3JjL2luZGV4JztcbnZhciBzbmFwQ29uZmlnID0ge1xuICAgIHNjcm9sbFNuYXBEZXN0aW5hdGlvbjogJzAlIDkwJScsXG4gICAgc2Nyb2xsVGltZW91dDogMTAwLFxuICAgIHNjcm9sbFRpbWU6IDMwMCxcbn07XG5mdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICBjb25zb2xlLmxvZygnc25hcCcpO1xufVxudmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJyk7XG52YXIgc25hcE9iamVjdCA9IG5ldyBTY3JvbGxTbmFwKGVsZW1lbnQsIHNuYXBDb25maWcpO1xuc25hcE9iamVjdC5iaW5kKGNhbGxiYWNrKTtcbi8vIHVuYmluZCBlbGVtZW50XG4vLyBzbmFwT2JqZWN0LnVuYmluZCgpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")}])});